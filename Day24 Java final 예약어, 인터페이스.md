<Day24 - 0422>
<JAVA final 예약어, 인터페이스>

# final 예약어

❤️ final 예약어의 의미?

- 마지막, 최종적이라는 의미. 변경 불가
- 마지막으로 정한 것이니 더 이상 수정할 수 없다는 뜻
- 자바 프로그램에서 final 예약어는 변수, 메서드, 클래스에 사용할 수 있음

❤️ final 예약어 사용 위치

1. 변수 : 상수 (final 변수는 상수를 의미)
2. 메서드 : 재정의 불가. 재정의 차단 (final 메서드는 하위 클래스에서 재정의할 수 없음)

   - 템플릿 메서드 패턴
   - 절차에 대한 메서드

3. 클래스 : 상속 불가 (final 클래스는 상속할 수 없음)

# 인터페이스

❤️ 인터페이스(interface)란?

- 설계라는 특수한 목적의 클래스 / 설계의 틀을 제공하는 클래스
- 추상 메서드만 정의하기 위한 클래스 (설계의 틀을 제공하기 위한 목적이므로)
- 설계의 틀을 제공하므로 유연하다

❤️ 인터페이스(interface)의 구성

- 인터페이스는 추상 메서드와 상수로만 이루어져 있음
- 구현된 코드가 없기 때문에 인스턴스를 생성할 수 없음

❤️ 인터페이스를 왜 쓰나요? - 설계의 틀을 제공하기 위한 클래스이므로! 인터페이스는 설계만을 위한 클래스★

(참고)

API (Application Programming Interface) : 개발시 필요한 설계 가이드라인 (어떻게 개발할 것인지 틀을 제공한다)

JDBC API (Java DataBase Connectivity Application Programming Interface)

❤️ 인터페이스 문법

- interface 인터페이스명 {
  추상 메서드 정의
  }
- 설계의 틀을 제공하기 위한 클래스이므로 설계 원칙을 정의하는 추상메서드만 가능함
- 인터페이스에 선언된 메서드는 모두 구현코드가 없는 추상메서드
- 메서드는 public abstract 예약어를 명시적으로 쓰지 않아도 컴파일 과정에서 자동으로 추상메서드로 변환됨 ★
- 인터페이스에 선언한 변수는 모두 컴파일 과정에서 값이 변하지 않는 상수로 자동 변환됨. public static final 예약어를 쓰지 않아도 무조건 상수로 인식 ★

❤️ 클래스에서 인터페이스 구현하기

- 인터페이스는 하위 클래스에서 메서드의 내용을 구현하느냐가 가장 중요
- 인터페이스에서는 인터페이스에 선언한 기능을 클래스가 구현한다는 의미로 implements 예약어를 사용함
- implement : 구현하다

class 클래스명 implement 인터페이스1, 인터페이스2... {}

❤️ 인터페이스 구현과 형변환(다형성)

- 인터페이스를 구현한 클래스가 있을 때 그 클래스는 해당 인터페이스형으로 묵시적 형변환이 이루어지며, 형 변환되었을 때 사용할 수 있는 메서드는 인터페이스에서 선언한 메서드뿐입니다.

❤️ 인터페이스의 요소 살펴보기

1. 인터페이스 상수

- 인터페이스는 추상 메서드로 이루어지므로 인스턴스를 생성할 수 없으며, 멤버 변수도 사용할 수 없음
- 인터페이스에 선언한 변수를 컴파일하면 상수로 변환됨

2. 디폴트 메서드

- 자바7에서 추가 (JDK1.8부터 인터페이스의 활용성을 높이기 위해 디폴트 메서드와 정적메서드 기능 제공)
- 인터페이스에서 구현 코드까지 작성한 메서드
- 완전 구현된 인스턴스 메서드 추가가 가능해짐
- 인터페이스를 구현한 클래스에 기본적으로 제공할 메서드
- 디폴트 메서드는 인터페이스에서 구현하지만, 이후 인터페이스를 구현한 클래스가 생성되면 그 클래스에서 사용할 기본 기능임★★★
- 디폴트 메서드를 선언할 때는 default 예약어를 사용
- 디폴트 메서드는 인터페이스에 이미 구현되어 있으므로 인터페이스를 구현한 추상 클래스나 추상클래스를 상속받은 클래스에서 코드를 구현할 필요가 없음
- 이미 인터페이스에 구현되어 있는 디폴트 메서드가 새로 생성한 클래스에서 원하는 기능과 맞지 않는다면, 하위 클래스에서 디폴트 메서드를 재정의 할 수도 있음 (오버라이딩 활용)

3. 정적 메서드

- static 예약어를 사용하여 선언하며 클래스 생성과 무관하게 사용할 수 있음
- 객체 생성과 관련 없이 독자적으로 사용 가능
- 인터페이스 명으로 직접 참조하여 접근 가능
- 인스턴스 생성과 상관없이 사용할 수 있는 메서드

4. private 메서드
   - 자바9에서 추가
   - private 메서드는 인터페이스를 구현한 클래스에서 사용하거나 재정의할 수 없음
   - 기존에 구현된 코드를 변경하지 않고 인터페이스를 구현한 클래스에서 공통으로 사용하는 경우에 private 메서드로 구현하면 코드의 재사용성을 높일 수 있음

❤️ 인터페이스 활용하기

1. 한 클래스가 여러 인터페이스를 구현하는 경우

- interface A

  - void method(); - (1)

- interface B

  - void method(); - (2)

- class C implements A, B

  - public void method(){...} - (3)

- 인터페이스는 추상 메서드이기 때문에 호출 주체가 명확함 (구현한 클래스의 메서드) => 다중 구현이 가능
- 인터페이스는 구현 코드나 멤버 변수를 가지지 않기 때문에 여러개를 동시에 구현할 수 있음
- 두 인터페이스에 이름이 같은 메서드가 선언되었다고 해도 구현은 클래스에서 이루어지므로, 어떤 메서드를 호출해야 하는지 모호하지 않음

(참고)

- 클래스에서는 다중 상속 시 인스턴스 메서드가 동일하면 하위 클래스가 호출 주체를 정하지 못함 => 다중 상속이 불가

- 클래스에서 상속은 단일 클래스만 상속 가능 (호출의 주체가 확실하지 않기 때문에 오류 발생. 애매함)

2. 두 인터페이스의 디폴트 메서드가 중복되는 경우

- 디폴트 메서드는 인스턴스를 생성해야 호출할 수 있는 메서드이기 때문에 다음처럼 이름이 같은 디폴트 메서드가 두 인터페이스에 있으면 문제가 발생함
- 하위 클래스에서 디폴트 메서드를 재정의하면, 재정의된 메서드가 호출되므로 오류를 해결할 수 있음

3. 인터페이스 상속하기 (extend)

- 개념간 체계를 나눌 때
- 인터페이스는 여러 개를 동시에 상속받을 수 있음
- 다중 상속 가능(추상 메서드) => 하위클래스가 구현하기 때문에 헷갈일 일이 없기 때문임 구현된 하위 메서드가 주체가 됨
- 한 인터페이스가 여러 인터페이스를 상속받으면, 상속받은 인터페이스는 상위 인터페이스에 선언한 추상 메서드를 모두 가지게 됨

💛💛💛 컴파일러가 자동으로 추가해주는 내용 💛💛💛

1. 기본 생성자 // 생성자를 정의하지 않은 경우
2. 모든 생성자에서 첫줄에 super 추가 // super를 추가하지 않은 경우
3. 참조 변수를 출력 -> 참조변수.toString()
4. 인터페이스의 객체화 조건에서 지역변수의 상수화 final
5. 인터페이스의 추상메서드 - public abstract
6. 인터페이스의 변수 정의(정적상수) : public static final
7. import java.lang.\*;
8. extends java.lang.Object

# MouseAdapter

- MouseAdapter에 기본 구현을 해둔 뒤, 클래스에서 필요한 기능을 가져가서 구현하여 사용

(참고)

컬렉션 프레임워크
(Collection Framework)

- Collection : 데이터 군집 : 자료
- Framework : 표준적인 설계 틀

자료구조

Collection 인터페이스

List 인터페이스 : 순차 자료구조 설계
Set 인터페이스 : 집합 자료구조 설계

Map 인터페이스 : 사전 자료구조 설계
