<Day20 - 0416>
<JAVA 생성자, 정보은닉, 접근제어자, this, static, 싱글톤패턴>

# 객체지향 프로그래밍 1

## 생성자

- 생성자가 하는 역할은 인스턴스의 생성과 인스턴스를 생성할 때 멤버 변수가 상수를 초기화 하는 것
- 생성자는 주로 멤버변수에 대한 값들을 매개변수로 받아서 인스턴스가 새로 생성될 때 멤버 변수 값들을 초기화하는 역할을 함
- 즉, 인스턴스가 생성됨과 동시에 멤버변수의 값을 지정하고 인스턴스를 초기화하기 위해 생성자를 직접 구현하여 사용함

---

## 디폴트 생성자

- 생성자는 클래스를 생성할 때만 호출함
- 생성자 이름은 클래스 이름과 같음
- 생성자는 반환값이 없음
- 생성자가 없는 클래스는 클래스파일을 컴파일 할때 자바 컴파일러에서 자동으로 생성자를 만들어 줌
- 이렇게 자동으로 만들어 주는 생성자를 디폴트 생성자(default constructor)라고 함
- 자바 컴파일러는 생성자가 하나도 없는 경우에만 디폴트 생성자를 제공함
- 객체를 만들 수 있는 수단이 하나도 없을 때 생성됨. 객체를 만드는 역할을 하기 때문
- 내부적으로 구현되어 있고, 통제 못하게 막혀있음
- 객체가 생성된 이후 실행 코드임
- 인스턴스 변수의 초기화 작업을 주로 수행 (변수의 값을 할당하는 역할을 주로 생성자가 담당함)
- 프로그래머가 생성자를 직접 추가하면 디폴트 생성자는 만들어지지 않음
- 디폴트 생성자는 매개변수가 없고 구현코드도 없음

---

## 생성자 오버로드

- 클래스에서 생성자가 두개 이상 제공되는 경우를 생성자 오버로드(constructor overload)함
- 필요에 따라 매개변수가 다른 생성자를 여러 개를 만들 수 있음
- 클래스에 생성자를 여러 개 제공하면 이 클래스를 사용하는 코드에서는 원하는 생성자를 선택해서 사용할 수 있음
- (참고) 객체지향 프로그램에서 메서드 이름이 같고 매개변수만 다른 경우를 메서드 오버로드라고 함

---

## 정보 은닉

- 멤버 변수에 직접 값을 대입하는 것 -> 통제가 불가하므로 사용을 지양 (멤버 변수의 접근 제어자(private))
- 객체 지향 프로그램에서는 예약어를 사용해 클래스 내부의 변수나 메서드, 생성자에 대한 접근 권한을 지정할 수 있음
- 이러한 예약어를 '접근 제어자(access modifier)'라고 함
- 정보은닉은 객체지향 프로그래밍의 특징 중에 하나이며 자바에서는 접근 제어자를 사용하여 정보은닉을 구현함
- 모든 변수를 private으로 선언해야 하는 것은 아니지만, 필요한 경우에는 private으로 선언하여 오류를 막을 수 있음

---

## 접근 제어자 정리

- public => 외부 클래스 어디에서나 접근할 수 있음. 모든 패키지 범위 내에서 접근이 가능
- protected => 같은 패키지 내부와 상속 관계의 클래스(외부 패키지 상속)에서만 접근할 수 있고 그 외 클래스에서는 접근할 수 없음. 범위는 default보다 넒음. 외부 패키지에서는 상속을 통하면 클래스 내부에서 접근 가능. default + 상속(private)
- default => 아무것도 없는 경우이며 같은 패키지 내부에서만 접근할 수 있음. 접근자 정의되지 않았을 때
- private => 같은 클래스 내부에서만 접근할 수 있음. 클래스 내부 메서드 내에서만 가능
- public > procted > default > private
- 외부 패키지 > 동일 패키지 + 외부 패키지 상속 > 동일패키지 >

---

## get(), set() 메서드

- 데이터를 담고 조회할 수 있음
- get멤버변수명() -> getter 함수
- set멤버변수명(...) -> setter 함수
- private으로 선언한 변수를 외부 코드에서 사용하려면 public 메서드를 제공해야 함

---

## this 예약어

- 객체의 자원을 접근하기 위한 용도
- this는 생성된 인스턴스 스스로를 가리키는 예약어
- this를 사용해 클래스의 생성자에서 다른 생성자를 호출할 수도 있음
- this를 사용하여 생성된 클래스 자신의 주소 값을 반환할 수도 있음
- 인스턴스 주소 값을 반환할 때는 this를 사용하고, 반환형은 클래스 자료형을 사용함
- this 값은 한번 만들어지면 변경되지 않음 (객체가 된 다음 만들어지기 때문임)

(변수) 함수의 지역변수

- 인스턴트 메서드의 지역변수임
- 메서드 내부에서 객체의 자원을 접근하기 위한 주소값

(함수) 생성자 메서드

- 클래스 내부에서 정의된 생성자를 호출
- 객체의 생성X, 생성자에 정의한 코드를 실행
- 생성자 메서드 내부에서 주로 사용
- 생성자 메서드의 첫 줄에만 사용 가능

- this 지역 변수 (함수의 지역변수)
  : 객체의 주소값
  -> 객체의 주소값이 필요한 이유? (객체를 활용하기 위해서, 객체의 자원을 접근하기 위한 목적, 객체의 자원을 쓰기 위해서)
  -> ★★★ 매서드 내부에서 객체의 자원을 접근하기 위한 목적으로 this 지역변수를 사용함 ★★★ 생성된 객체의 주소값을 가지고 있다

: 생성자 메서드(생성자 함수)
-> 객체를 생성하는 것이 아니라 정의한 코드를 실행하는 용도

---

## static 변수

- static : 정적인, 고정된 (반대 : 동적인, 움직이는)
- 메모리는 정적 메모리와 동적 메모리가 있음
- 동적 메모리에는 스택 영역 메모리와 힙 영역 메모리가 있음 (생성과 소멸을 반복)
- 정적 메모리에는 데이터 영역 메모리가 있음 (변하지 않는 데이터, 코드 & 상수 영역, 애플리케이션 시작시 생성, 종료시 제거)
- 클래스에서 공통적으로 사용하는 변수를 'static 변수'로 선언함
- static 변수는 다른 용어로 **정적변수**라고도 함
- static 변수는 클래스 내부에 선언하지만, 다른 멤버 변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아님
- static 변수는 프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 메모리 공간에 할당됨. 시작할 때 할당됨. 처음 로드 될때부터 공간 할당
- 그리고 그 값은 모든 인스턴스가 공유함
- static으로 선언한 변수는 인스턴스 생성과 상관없이(객체가 생성되는 것과 관련 X) 먼저 생성되고(공간을 할당받고) 그 값을 모든 인스턴스가 공유하게 되는 것임
- static은 자원을 공유하기 때문에 맨 마지막에 바뀐 값으로 적용됨
- 이런 이유 때문에 static 변수를 클래스에 기반한 변수라고 해서 **클래스 변수(class variable)**라고도 함
- static 변수는 같은 클래스에서 생성된 인스턴스들이 같은 값을 공유할 수 있으므로, 인스턴스 간에 공통으로 사용할 값이 필요한 경우 사용할 수 있음
- 클래스명으로 직접 접근도 가능

---

## 클래스 변수

- static 변수는 인스턴스를 생성할 때마다 만들어지는 것이 아니고 클래스를 선언할 때 특정 메모리에 저장되어 모든 인스턴스가 공유하는 변수임
- static 변수는 인스턴스 생성과는 별개이므로 인스턴스보다 먼저 생성됨
- 그러므로 인스턴스가 아닌 클래스 이름으로도 참조하여 사용할 수 있음
- 클래스로 접근하기 때문에 클래스이름.클래스변수로 사용 가능
- 따라서 자바에서는 static 변수를 클래스 변수라고도 함
- static변수, 정적변수, 클래스변수라는 세가지 용어가 있지만 모두 static변수로 같은 의미임☆☆☆
- 자바에서 static변수를 클래스 변수라고 하는 이유는 인스턴스마다 생성되는 변수가 아니라 클래스에 속해 한 번만 생성되는 변수이고, 이를 여러 인스턴스가 공유하기 때문임

---

## 클래스 매서드 (static 메서드)

- static 변수를 위한 메서드
- 객체 생성과 상관 없이 사용이 가능함
- 클래스명으로 직접 호출 가능
- 이런 메서드를 static메서드 또는 클래스 메서드라고 함
- 클래스 메서드 내부에서는 인스턴스 변수를 사용할 수 없음
- 클래스 메서드 내부에서는 인스턴스 메서드 역시 사용할 수 없음
- 클래스 변수, 클래스 메서드는 인스턴스가 만들어지기 이전에 존재하므로 인스턴스에 접근할 수 없음
- 클래스 변수, 클래스 메서드는 인스턴스가 생성되지 않아도 사용할 수 있음

---

## 변수의 유효범위

- 지역변수의 유효범위

  - 함수의 지역 안에서만 유효함
  - 함수가 호출, 실행 시에만 스택에서 공간을 할당
  - 함수의 연산이 종료되면(return), 스택에서 제거됨
  - 함수의 지역 안에서만 유효한 변수
  - 지역변수는 함수나 메서드 내부에 선언하기 때문에 함수 밖에서는 사용할 수 없음
  - 스택에서 생성되는 지역변수는 함수가 호출될 때 생성되었다가 함수가 반환되면 할당되었던 메모리 공간이 해제되면서 함께 없어짐

- 멤버변수(인스턴스 변수)의 유효범위

  - 클래스가 생성될 때(객체가 생성될 때) 힙(heap)메모리에 생성되는 변수
  - 객체의 참조가 끊어지면(더이상 사용하는 참조 변수가 없으면), 가비지 콜렉터(GC)가 제거함
  - 멤버변수는 인스턴스 변수라고도 함
  - 멤버변수는 클래스의 어느 메서드에서나 사용할 수 있음
  - 힙에 생성된 인스턴스가 가비지 컬렉터(garbage collector)에 의해 수거되면 메모리에서 사라짐

- static 변수의 유효범위

  - 애플리케이션 로딩 시 처음부터 데이터 영역에 할당되는 변수
  - 애플리케이션 종료시 제거되는 변수
  - static 변수는 클래스 생성과 상관 없이 데이터 영역 메모리에 생성됨
  - 인스턴스 변수와 static 변수는 사용하는 메모리가 다름
  - static 변수는 private이 아니라면 클래스 외부에서도 객체생성과는 무관하게 사용할 수 있음
  - 프로그램 실행이 끝난 뒤에 메모리에서 내려가면 static 변수도 소멸됨
  - static 변수는 프로그램이 시작할 때 부터 끝날 때 까지 메모리에 상주하므로 크기가 너무 큰 변수를 static으로 선언하는것은 좋지 않음

---

## static 응용 - 싱글톤 패턴

- 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴을 싱글톤 패턴(singleton pattern)이라고 함
- 메모리를 절약하는 방법 패턴 (한개를 가지고 공유하는 방법으로)

java.lang.Math

- 수학 관련 편의 기능 모음 클래스

java.util.Arrays

- 배열을 다룰 때 사용할 수 있는 편의 기능 모음 클래스

편의 기능 모음 클래스의 경우는 객체를 여러개 생성할 필요가 X
-> 메서드나, 변수, 상수를 static으로 정의한 경우가 많다
-> static 문제점? static : 처음부터 공간 할당, 활성화 -> 사용하지 않아도 이미 메모리를 차지 -> 싱글톤 패턴으로 해결

1. 기능을 담당하는 객체는 여러개 만들 필요가 없음
2. 이 기능이 항상 필요한 것은 아님. 필요할 때만 객체 생성
3. 객체는 필요할때 하나만 생성하고 공유

① 생성자를 private으로 만들기 (생성자를 외부에서 직접 호출X, 접근제어자 private 변경)

- 생성자가 public 이면 외부에서 인스턴스를 여러개 생성할 수 있음
- 싱글톤 패턴에서는 생성자를 반드시 명시적으로 만들고 그 접근 제어자를 private으로 지정해야 함
- 그러면 생성자가 있으므로 컴파일러가 디폴트 생성자를 만들지 않고, 접근 제어자가 private이므로 외부 클래스에서 마음대로 Company 인스턴스를 생성할 수 없게 됨
- 즉, Company 클래스 내부에서만 클래스의 생성을 제어할 수 있게 됨

② 클래스 내부에 static으로 유일한 인스턴스 생성하기 (클래스 내부에 객체를 생성)

- private으로 선언하여 외부에서 이 인스턴스에 접근하지 못하도록 제한해야 함

③ 외부에서 참조 할 수 있는 public 메서드 만들기 (클래스 내부에서 생성된 객체를 반환하는 함수)

- private으로 선언한 유일한 인스턴스를 외부에서도 사용할 수 있도록 설정해야 함
- 이를 위해 public 메서드를 생성함. 그리고 유일하게 생성한 인스턴스를 반환해 줌
- 이 때 인스턴스를 반환하는 메서드는 반드시 static으로 선언해야 함
- 인스턴스 생성과 상관없이 호출할 수 있어야 하기 때문임

---

(참고)

함수의 이름 - 함수의 시그니처

패키지명 + 클래스명 + 반환값 + 함수명 + 매개변수 정의 + 예외 전가

함수의 시그니처가 동일 -> 함수의 중복 정의 -> 오류
함수의 시그니처가 동일 X -> 함수명이 같아도 다른 함수를 정의한 것

인스턴스 메서드(멤버 메서드) : 객체가 되면 호출할 수 있는 메서드

함수는 인스턴스 메서드 영역 데이터 영역 메모리에 코드와 함께 추가됨
함수가 수행하는 로직은 바뀔리가 없기 때문임
함수는 바뀌지 않고 모든 객체가 공유함 (그래서 상수처럼 데이터 영역에서 관리함)
