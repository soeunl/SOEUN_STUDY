<Day25 - 0423>
<JAVA 예외처리>

# 예외처리

❤️ 예외처리의 목적? - 서비스가 중단되는 것을 막기 위하여!
예외 처리를 하는 목적은 프로그램이 비정상 종료 되는 것을 방지하기 위한 것

💜예외 처리를 한다고 해서 프로그램의 예외 상황 자체를 막을 수는 없음. 하지만 예외 처리를 하면 예외 상황을 알려 주는 메시지를 볼 수 있고, 프로그램이 비정상 종료되지 않고 계속 수행되도록 만들 수 있음!💜

❤️ 오류란 무엇인가?

- 컴파일 오류(compile error) : 프로그램 코드 작성 중 실수로 발생하는 오류, 문법적으로 오류가 있는 상태

- 실행 오류(runtime error) : 실행 중인 프로그램이 의도하지 않은 동작을 하거나 프로그램이 중지되는 오류. 실행 오류 중 프로그램을 잘못 구현하여 의도한 바와 다르게 실행되어 생기는 오류를 버그(bug)하고 함

❤️ 오류와 예외?

1.  오류와 예외

    - 시스템 오류(Error) : 자바 가상머신에서 발생. 시스템의 오류, JVM 오류 ... : 통제 불가 오류, 프로그램에서 제어할 수 없음

    - 예외(Exception) : 코드 상의 오류 : 통제 가능한 오류 - 버그. 프로그램에서 제어할 수 있음

    - 오류 클래스는 모두 Throwable 클래스에서 상속받음
    - Error 클래스의 하위 클래스는 시스템에서 발생하는 오류를 다루며 프로그램에서 제어하지 않음. 프로그램에서 제어하는 부분은 Exception 클래스와 그 하위에 있는 예외 클래스임

2.  예외 클래스의 종류

          Throwable

        Exception Error

    - 프로그램에서 처리하는 예외 클래스의 최상위 클래스는 Exception 클래스임

    ```Java
    Class Exception

    java.lang.Object
        java.lang.Throwable
            java.lang.Exception

    ```

❤️ Exception

1. 💙Exception을 바로 상속 받은 예외 클래스💙

(예) java.io.IOException / 파일을 읽을때, 쓸때 (FileInputStream, FileOutputStream)

java.io.FileNotFoundException

- 예외가 있든 없든 처리가 안되어 있으면 컴파일 되지 않음
- 예외의 체크는 컴파일시 체크, 예외가 있으면 컴파일 되지 않음
- 예외가 발생하든 안하든 반드시 적절한 예외 처리가 필요한 예외
  (엄격한 예외, 형식을 매우 중시. 적절한 예외처리가 반드시 필요)★★★
- RuntimeException이 없으면 컴파일 시점에 체크하므로 컴파일 자체를 시켜주지 않음 => class파일 자체를 만들어주지 않음 (컴파일러가 체크해보고 실행 자체를 시키지 않음)

2. 💙 RuntimeException을 중간에 상속 받은 예외 클래스💙

Runtime : 실행
(예) java.lang.ArithmethicException : 0으로 나눌때 발생

- RuntimeException은 try ~ catch문을 사용하여 예외 처리를 하지 않아도 컴파일 오류가 나지 않음. 예외 전가도 처리하지 않아도 컴파일 오류가 발생하지 않음
- 예외가 발생하더라도 컴파일은 됨, class 파일 생성
- 예외의 체크는 실행 중 체크 (실행이 되려면? class 파일 필요하므로)(컴파일은 된다...) - 유연한 예외, 형식은 X
- RuntimeException이 있으면 컴파일은 실행이 되기 때문에 class 파일이 생성됨 (컴파일러가 class 파일을 만든 후 체크. 실행중에 체크)
- 실행중에 체크하다가 오류가 발생하면 프로그램 중단
- 컴파일러에 의해 체크되지 않는 예외는 프로그래머가 알아서 처리해야 하므로 주의해야 함

예외가 발생하면 프로그램 중단! -> 프로그램 중단을 막기 위한 조치 - 예외처리의 목적 : 예외가 발생시 적절한 조치 -> 서비스 중단을 막는 것

(참고)
java.exe : 클래스파일 실행
javac.exe : java -> class 컴파일

❤️ 예외 처리하기

1. try ~ catch문

```Java

try {
// 예외가 발생할 가능성이 있는 코드
} catch (처리할 예외 타입 e) {
// 예외 발생시 처리할 코드
// try 블록 안에서 예외가 발생했을 때 예외를 처리하는 부분
}

// try ~ catch문을 사용하면 서비스가 중단되지 않음

```

- try 블록에는 예외가 발생할 가능성이 있는 코드를 작성
- try 블록 안에 예외가 발생하면 바로 catch 블록이 수행됨
- catch문의 괄호()안에 쓰는 예외 타입은 예외 상황에 따라 달라짐

(참고)

예외 발생
throw 예외객체;

    예외, 오류 -> 원인을 확인을 하는것이 중요★★★


    예외 클래스 주요 메서드 : 정보확인
    		java.lang.Throwable
                - String getMessage() : 오류 메세지 확인 (오류 메세지로 알려줌)
                - void printStackTrace() : 발생 위치를 쌓아가면서 찾아가는 형태 (찾으면 발생위치부터 파생위치까지 알려줌)

- 다중 예외가 발생했을때는 catch를 여러개 사용하여 그에 맞는 처리를 함
- 여러개의 예외 타입을 붙여서 함께 표시할 수 있음

2. try-catch-finally문

   - try 블록이 수행되면 finally 블록은 어떤 경우에도 반드시 실행됨
   - try나 catch에 return문이 있어도 수행됨
   - 자원을 소비하는 객체 - FileInputStream, FileOutputStream, Connection, PrepareStatement ...
   - 자원 해제 -> 애플리케이션 종료시에 해제
   - 서버? 종료 X -> 자원해제를 하지 않으면 메모리 부족 현상 발생 (자원이 쌓이고 쌓여서)
   - 자원해제를 적절하게 해야 된다.(close()...)
   - 사용한 시스템 리소스는 사용 후 반드시 close() 메서드로 닫아 주어야 함
   - finally 쪽에서는 주로 자원해제를 함
   - try나 catch에 return문이 있어도 수행됨 그러므로 열린 리소스는 예외 발생과 상관없이 항상 닫혀야 하므로 finally 블록에 파일 리소스를 닫는 코드를 구현해야 함

```Java

   try { // 예외가 발생할 수 있는 부분

   } catch (처리할 예외 타입 e) {
   ...
   } finally {
   // 예외가 발생하든 안하든 항상 실행되는 코드
   // return 하더라도 코드가 실행
   }

```

3. try-with-resources문

   - JDK7에서 추가
   - 자원 해제를 자동으로 해주는 구문
   - AutoCloseable 인터페이스 구현체이면 자동으로 close 메서드를 호출할 수 있음

```Java

   try ( 해제할 자원 객체;
   해제할 자원 객체 ...) {
   // 예외가 발생할 가능성이 있는 코드
   } catch(예외 객체 ...) {
   }

```

# try-with-resources문을 사용하게 된 이유와 사용법

⑴ 서버는 24시간 돌아간다
⑵ 그러므로 쓰지 않는 메모리는 계속 쌓이므로 자원 해제가 필요하다
⑶ try-catch-finally문에서 finally는 항상 실행되는 부분이다
⑷ 그러므로 자원해제는 finally에 close() 메서드를 구현한다 (항상 실행되어야 하므로)
⑸ 하지만 finally에서 자원을 해제하는 과정은 불편하고 코드가 너무 길다
⑹ JDK1.7 부터 try-with-resources문을 제공하여 close() 메서드를 명시적으로 호출하지 않아도 try 블록 내에서 자동으로 close()가 호출되도록 하였다
⑺ try-with-resources 문법을 사용하려면 AutoCloseable 인터페이스의 구현 클래스가 있어야 close()를 자동으로 호출할 수 있다 (이것이 기준이 된다)
⑻ 객체 안에 AutoCloseable 인터페이스의 구현 클래스가 있는지 체크가 가장 중요하다
⑼ AutoCloseable 인터페이스에는 close()메서드가 있고, 이를 구현한 클래스는 close()를 명시적으로 호출하지 않아도 close() 메서드 부분이 자동으로 호출되기 때문이다
⑽ 여러개의 객체를 자원해제 할때는 자원해제 할 객체를 try문의 괄호() 안에 ;로 구분하여 나열하면 자동으로 close()를 호출해준다

💜 이처럼 try-with-resources문을 사용하면 close() 메서드를 명시적으로 호출하지 않아도, 정상 종료된 경우와 예외가 발생한 경우 모두 리소스가 잘 해제됨 💜

❤️ 자원 자동해제의 기준
AutoCloseable 인터페이스의 구현 클래스 - close() 메서드를 자동 호출

❤️ 예외 처리 미루기

1. 예외 처리를 미루는 throws 사용하기

   - 예외를 해당 메서드에서 처리하지 않고 미룬 후 메서드를 호출하여 사용하는 부분에서 예외를 처리하는 방법
   - 메서드를 호출 하는쪽에서 예외 처리 전가 (호출한 쪽에서 처리하게 됨)
   - 예외 처리를 각각 다른 방법으로 할수 있기 때문에 예외 처리를 전가시킴
   - 전가시키는 예외에 대해서 명시(throws)
     메서드 매개변수 뒤쪽에 throws 전가할 예외 작성
   - Exception을 상속 받은 경우(RuntimeException이 없는 경우) 사용할 수 있음

2. 다중 예외 처리

   - 어떤 예외가 발생할지 미리 알수 없지만 모든 예외 상황을 처리하고자 한다면 맨 마지막 부분에 Exception 클래스를 활용하여 catch 블록을 추가함
   - Exception 클래스는 모든 예외 클래스의 최상위 클래스이므로, 다른 catch 블록에서 선언한 것 이외의 예외가 발생하더라도 Exception 클래스로 자동 형 변환 됨(다형성)
   - 가장 처음 Exception이 catch 구간에 있다면 모든 예외가 이 구간으로 유입이 되어 적절한 처리가 되지 않기 때문에 기본 예외 처리를 하는 Exception 클래스 블록은 여러 예외 처리 블록의 가장 아래 놓여야 함

3. 사용자 정의 예외
   - JDK 기본 정의 예외 외에 따로 작성하는 예외
   - Exception 클래스에서 상속받아 구현
   - Exception 클래스에서 메세지 생성자, 멤버 변수와 메서드를 이미 제공하고 있으므로 super(message)를 사용하여 메시지를 설정
   - 나중에 getMessage() 메서드를 호출하면 메시지 내용을 볼 수 있음
