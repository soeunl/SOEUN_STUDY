<Day28 - 0426>
<JAVA 지네릭스>

# 지네릭스

❤️지네릭스란?

- 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일시의 타입체크를 해주는 기능
- 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어듬
- 다룰 객체의 타입을 미리 명시해줌으로써 번거로운 형변환을 줄여줌

❤️지네릭스를 사용하게 된 이유?!

1. 형 변환의 번거로움
2. 타입 안정성이 떨어지는 문제

(참고)

- 다양한 자료형을 수용할 때 -> Object 클래스 사용
  단점
  1. 타입 안정성 X
  2. 형변환의 번거로움

❤️지네릭 클래스의 선언
public class Box

❤️지네릭스의 용어

1. 지네릭 클래스
   class Box<T> { .... }
2. 타입변수 T -> 컴파일시에 형식 오류로 제거 / 타입 매개변수 T는 우선 Object로 변경 -> 객체를 만드는 시점에 있는 타입 힌트를 통해서 형변환이 발생
3. 원시타입 Box

❤️지네릭스 컴파일 과정

- 타입 매개변수는 컴파일시 제거(문법적으로 형식에 맞지 않기 때문에) -> 컴파일 시 Object로 변경 -> 객체가 생성될때 타입 매개변수의 자료형으로 형변환 (타입은 객체 생성시 투입된 자료형으로 결정)
- 컴파일 시점에는? 자료형이 명확하게 결정되어 있어야 컴파일 가능 -> 컴파일러가 알 수 있는 형태로 자료형 결정 (모든 클래스는 Object의 하위 클래스임을 알고 있다 -> 자료형을 Object로 결정)
- <T> : 형식상의 오류
- 컴파일 시점에 형식상의 오류를 해결하기 위해서 지네릭 타입은 모두 제거

❤️자료형 결정 시점

- 객체를 생성하는 시점에 타입 힌트를 통해서 형변환이 발생(Object -> Apple)
- (예) Box<Apple> applebox = new Box<Apple>();
- Object -> (Apple)

❤️사용의 제한점

1. 정적 변수는 사용 불가 (private static T item(X)) -> 사용이 불가함, 처음부터 공간을 할당 받으므로 자료형이 명확해야 함 (static멤버에 타입 변수 T를 사용할 수 없음)

- 지네릭 타입의 자료형은 객체 생성 시점에만 결정되므로 처음부터 자료형이 결정되어야 하는 변수에는 사용이 불가함
- static 멤버 변수에는 타입 매개변수 사용 불가 - 처음부터 자료형이 명시 되어야 공간을 할당

2. 배열 사용 불가

- 지네릭 타입의 배열을 생성하는 것도 허용하지 않음
- new 연산자 때문 : 메모리에 공간 생성 역할
- 배열 생성 불가 -> new 연산자는 배열 공간을 생성하는데, 명확한 자료형을 알아야 공간을 계산을 하기 때문

3. 타입 매개변수와 동일한 자료형

- 타입 매개변수를 가지는 참조 변수와 인스턴스는 타입 매개변수에 동일한 자료형을 입력해야 함

❤️지네릭 클래스의 객체 생성과 사용

<T extends 타입> -> T 는 타입의 하위 클래스 (타입은 추상클래스가 되거나 인터페이스가 될 수 있음)
<T extends 타입1 & 타입2> -> T는 타입1의 하위 클래스 이고 타입2 인터페이스의 구현 클래스
extends 뒤쪽의 타입들로 형을 한정하여 범위 제한

★★★ 메서드 내부에서 접근 가능한 지네릭 타입 인스턴스 자원은 모두 Object형
-> 형변환된 객체에 정의된 인스턴스 자원 접근 X
-> 공통된 틀을 정해서 타입 매개변수의 하위 클래스임을 정의
-> <T extends Fruit> -> T는 fruit의 하위 클래스임을 알 수 있음 -> Object 보다는 Fruit로 변환

❤️와일드 카드

- 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않음
- 지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거해버리기 때문, 메서드는 오버로딩이 아니라 메서드 중복 정의가 되어버림
- 이럴 때 사용하기 위해 고안된 것이 바로 와일드 카드!
- 와일드 카드는 기호 <?>로 표현하는데, 와일드 카드는 어떠한 타입도 될 수 있음
- <?>만으로는 Object타입과 다를 게 없으므로, 다음과 같이 'extends'와 'super'로 상한(upper bound)와 하한(lower bound)를 제한할 수 있음

   <?> -> 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
   <? extends 타입> -> T는 타입의 하위 클래스 : 타입으로 상한 제한 
      <? extends 클래스형 & 인터페이스형> : 사용 불가, 지네릭 클래스에서만 가능
   <? super 타입> -> T는 타입의 상위 클래스 : 타입으로 하한 제한

❤️지네릭 메서드

- public static <T extends Fruit> void make3(FruitBox<T> box) {}
- extends만 가능함
- 와일드카드를 사용하면 정의부분이 너무 길어지는데, 지네릭 메서드를 통해 정의부분을 조금 줄여서 표현할 수 있음

❤️지네릭 클래스와 지네릭 메서드의 차이

- 💙 클래스가 객체가 될 때 T가 결정 - 지네릭 클래스의 T
- 💙 호출 시 T의 자료형이 결정 - 지네릭 메서드의 T
- 두개의 T는 같은 T가 아니다

- 타입을 클래스에 정의하면 : 지네릭 클래스
  (예) class Box<T> : T의 자료형은 객체가 생성될때 결정

- 타입을 메서드의 반환값 타입 앞에 정의하면 : 지네릭 메서드
  (예) public<T,U> String method(T str1, U str2); : T, U의 자료형은 함수가 호출될 때 결정
