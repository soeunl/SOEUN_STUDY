<Day11 - 0402>
<React 리액트의 이해, JSX 코드 이해하기>

# 리액트의 이해

- 자바스트립트 라이브러리로 사용자 인터페이스를 만드는 데 사용함
- 리액트는 프레임워크가 아닌 V(View)만 신경쓰고 있는 라이브러리
- 그러나 다양한 라이브러리를 조합해서 사용가능

★컴포넌트란?★ - 리액트 프로젝트에서 특정 부분이 어떻게 생길지 정하는 선언체
재사용이 가능한 API로 수많은 기능들을 내장하고 있으며, 컴포넌트 하나에서 해당 컴포넌트의 생김새와 작동 방식을 정의함

★렌더링이란?★ - 사용자 화면에 뷰를 보여주는 것

1. ☆ 초기 렌더링 ☆

- 맨 처음 어떻게 보일지를 정하는 초기 렌더링이 필요함
- 리액트에서는 이를 다루는 render 함수가 있음

* render() { ... } 함수
  - 이 함수는 컴포넌트가 어떻게 생겼는지 정의하는 역할을 함
  - 이 함수는 html 형식의 문자열을 반환하지 않고, 뷰가 어떻게 생겼고,
    어떻게 작동하는지에 대한 정보를 지닌 객체를 반환함
  - 컴포넌트 내부에는 또 다른 컴포넌트들이 들어갈 수 있음
  - 컴포넌트를 실제 페이지에 렌더링할 때는 분리된 두 가지 절차를 따름
    ⁂ 문자열 형태의 HTML 코드가 생성됨
    ⁂ 특정 DOM에 해당 내용을 주입하면 이벤트가 적용됨

2. ☆ 조화과정 ☆

   - 리액트에서 뷰를 업데이트할 때는 "업데이트 과정을 거친다"라고 하기 보다는 "조화 과정(reconciliation)을 거친다"라고 표현함
   - 컴포넌트에서 데이터에 변화가 있을 때 변화에 따라 뷰가 변형되는 것처럼 보이지만, ★사실 새로운 요소로 갈아 끼우기 때문임★
   - 이 작업은 render 함수가 맡아서 함
   - 컴포넌트는 데이터를 업데이트했을 때 단순히 업데이트한 값을 수정하는 것이 아니라 새로운 데이터를 가지고 render 함수를 또 다시 호출하고, 그 데이터를 지닌 뷰를 생성해 냄
   - 하지만 이때 render 함수가 반환하는 결과를 곧바로 DOM에 반영하지 않고, 이전에 render 함수가 만들었던 컴포넌트 정보와 현재 render 함수가 만든 컴포넌트 정보를 비교함

     ⁂ 자바스크립트를 사용하여 두 가지 뷰를 최소한의 연산으로 비교한 후, 둘의 차이를 알아내 최소한의 연산으로 DOM 트리를 업데이트함 ⁂

---

# 리액트의 특징

1. ☆ Virtual DOM ☆

- 리액트의 주요 특징 중 하나는 ☆Virtual DOM☆을 사용하는 것
- Virtual DOM을 이용하면 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용할 수 있음
- 실제 DOM의 가벼운 사본과 비슷
- Virtual DOM을 사용하면 실제 DOM에 접근하여 조작하는 대신, 이를 추상화한 자바스크립트 객체를 구성하여 사용함. 마치 실제 DOM의 가벼운 사본과 비슷

💕리액트는 Virtual DOM 방식을 사용하여 DOM 업데이트를 추상화함으로써 DOM 처리 횟수를 최소화하고 효율적으로 진행함💕

★ DOM이란? ★

- DOM은 Document Object Model의 약자
- 즉, 객체로 문서 구조를 표현하는 방법으로 XML이나 HTML로 작성함
- 웹 브라우저는 DOM을 활용하여 객체에 자바스크립트와 CSS를 적용함
- DOM은 트리 형태라서 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할 수 있음

2. ☆ 리액트에서 데이터가 변하여 웹브라우저 실제 DOM을 업데이트 하는 절차☆

- ① 데이터를 업데이트하면 전체 UI를 Virtual DOM에 리렌더링 ☆
- ② 이전 Virtual DOM에 있던 내용과 전체 내용을 비교 ☆
- ③ 바뀐 부분만 실제 DOM에 적용 ☆

---

# 작업 환경 설정

1. ☆ Node.js 설치 ☆ (Node.js 공식 다운로드 페이지에서 Windows Installer를 내려받아 설치)

2. ☆ yarn 설치 ☆ (npm install --global yarn)

- yarn은 npm을 대체할 수 있는 도구로 npm보다 더 빠르며 효율적인 캐시 시스템과 기타 부가 기능을 제공함
- npm과 동일한 역할 수행, 메타쪽에서 개발, 설치 속도가 빠름, UI가 깔끔
- 10 - 메이저 버전 : 하위 버전과 호환되지 않은 큰 변화
  5 - 마이너 버전 : 호환성 X, 기능 추가, 변경사항이 있는 경우
  1 - 패치 : 오류 수정, 보완

      (참고)

      npm으로 script의 명령어 실행
      npm run start
      npm run build

      yarn start
      yarn build

3. ☆ 에디터 설치(vscode) ☆

   - 확장 프로그램 설치
     ① ESLint : 자바스크립트 문법 및 코드 스타일을 검사해주는 도구
     ② Reactjs Code Snippets : 리액트 사용시 단축 단어를 사용하여 코드 자동완성할 수 있는 도구(제작자가 charalmpos karypidis 인 것 선택)
     ③ Prettier-Code formatter : 코드 스타일을 자동으로 정리해 주는 도구

4. ☆ create-react-app으로 프로젝트 생성하기☆

- yarn create react-app hello-react (터미널을 열고 프로젝트를 만들고 싶은 디렉토리에서 명령어 실행)

- yarn을 사용하지 않는 경우
  (npm init react-app 프로젝트 이름)

- cd hello-react
  yarn start (프로젝트 생성이 완료되었다면 명령어를 입력하여 프로젝트 디렉터리로 이동한 후 리액트 개발 전용 서버를 구동)

---

# JSX 코드 이해하기

1. ☆ 코드 이해하기 ☆

- import logo from "./logo.svg";
  import "./App.css";
  = import 구문 : 이는 특정 파일을 불러오는 것을 의미, 리액트로 만든 프로젝트의 자바스크립트 파일에서는 import를 사용하여 다른 파일들을 불러와 사용할 수 있음

2. ☆ JSX란? ☆

- JSX는 자바스크립트의 확장 문법이며 XML과 매우 비슷하게 생김
- 이런 형식으로 작성한 코드는 브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환됨
- JSX는 보기 쉽고 익숙함 (HTML 코드를 작성하는 것과 비슷하기 때문)
- 활용도가 높음 (JSX에서는 div나 span과 같은 HTML 태그를 사용할 수 있을 뿐만 아니라, 앞으로 만들 컴포넌트도 JSX 안에서 작성할 수 있음)

---

# JSX 문법

1. ☆ 감싸인 요소 ☆

- 소괄호를 활용해 감싸야 함
- 반드시 하나의 요소(태그)에 의하여 감싸여 있어야 함 (반드시 부모 요소 하나로 감싸야 함)
- Virtual DOM에서 컴포넌트의 변화를 감지해 낼 때 효율적으로 비교할 수 있도록 컴포넌트 내부는 하나의 DOM 트리 구조로 이루어져야 한다는 규칙이 있기 때문
- 꼭 div 요소를 사용하지 않아도 Fragment 태그로 사용도 가능 (노출되지 않으면서 감싸기 가능)
- Fragment 태그는 <> ~ </>로 표현 가능

2. ☆ 자바스크립트 표현 ☆

- JSX 안에서는 자바스크립트 표현식을 쓸 수 있음
- 자바스크립트 표현식을 작성하려면 JSX 내부에서 코드를 { }로 감싸면 됨
  (ex) {name}

3. ☆ if문 대신 조건부 연산자(삼항조건식) ☆

- 조건식 ? 참 : 거짓
- JSX 내부의 자바스크립트 표현식에서 if문을 사용할 수는 없음
- 하지만 조건에 따라 다른 내용을 렌더링해야 할 때는 JSX 밖에서 if문을 사용하여 사전에 값을 설정하거나 / { }안에서 조건부 연산자(삼항연산자)를 사용할 수 있음

4. ☆ AND 연산자(&&)를 사용한 조건부 렌더링 ☆

- function App() {
  const name = '리액트';
  return <div>{name === '리액트' && <h1>리액트입니다.</h1>}</div>;
  }

export default App;

- && 연산자로 조건부 렌더링을 할 수 있는 이유는 리액트에서 false를 렌더링할 때는 null과 마찬가지로 아무것도 나타나지 않기 때문임
- 여기서 한 가지 주의해야 할 점은 falsy한 값인 0은 예외적으로 화면에 나타난다는 것★

5. ☆ undefined를 렌더링하지 않기 ☆

- 리액트 컴포넌트에서는 함수에서 undefined만 반환하여 렌더링하는 상황을 만들면 안됨(오류 발생함)
- 어떤 값이 undefined일 수도 있다면, OR(||) 연산자를 사용하면 해당 값이 undefined일 때 사용할 값을 지정할 수 있으므로 간단하게 오류를 방지할 수 있음

6. ☆ 인라인 스타일링 ☆

- CSS는 객체 형태로 넣어 주어야 함
- 스타일 이름 중에서 background-color 처럼 - 문자가 포함되는 이름이 있을때는 -을 제거하고 카멜 표기법으로 작성 (background-color는 backgroundColor로 작성)

7. ☆ class 대신 className ☆

- 일반 HTML에서 CSS 클래스를 사용할 때는 <div class="myclass"></div>와 같이 class라는 속성을 설정하지만, JSX에서는 class가 아닌 className으로 설정해 주어야 함

8. ☆ 꼭 닫아야 하는 태그 ☆

- JSX에서는 태그를 닫지 않으면 오류가 발생함
  <input></input>
  <input />

9. ☆ 주석 ☆

- {/_ ... _/} 형식으로 작성
- 시작태그를 여러 줄로 작성할 때는 그 내부에서 // ... 와 같은 형태로 작성할 수 있음

---

# ESLint와 Prettier 적용하기

1. ☆ ESLint ☆

- ESLint는 문법 검사 도구
- 보기 > 문제를 클릭하여 확인

2. ☆ Prettier ☆

- Prettier는 코드 스타일 자동 정리 도구
- VS Code에서 F1을 누르고 format이라고 입력한 후 Enter를 누르면 자동 정리
- 자동으로 코드 정리를 하려면
- 파일 -> 기본 설정 -> 설정 -> Format On Save 옵션 체크 : 저장시 자동 정리
- 설정 파일 작성

  .prettierrc

  {
  "singleQuote": true,
  "semi": true,
  "useTabs": false,
  "tabWidth": 2,
  "trailingComma": "all"
  }

---

(참고)

- 직접 작성한 파일, 자원을 로드
  import ... from "./..." -> 동일 경로
  import ... from "../..." -> 상위 경로
  import { Fragment } from 'react' -> node_modules/react/index.js

-> WebPack 사용하여 파일을 묶듯이 연결할 수 있음
-> index.html, ...css, ...js

import : 모듈 가져오기
export : 모듈 내보기

import React from 'react'; => from뒤는 모듈 경로
import './index.css'; => src 파일 불러오는 법
import React from 'react'; => moudle에서 불러올때는 ./를 쓰지 않아도 된다.
import App from './App'; => import 뒷 부분은 변수명

- 모든 module에는 index.js가 포함되어 있음. 불러올때는 생략가능. 쓰지 않아도 붙어 있음
- import로 모듈 불러올때는 js는 확장자 생락가능. css, html 등은 확장자 생략할 수 없음

export default 변수명 -> import 변수명(변경 가능) from ... : 모듈을 1개만 내보기 가능

export 변수명 : 모듈을 여러개 내보내기 가능 -> import {변수명} from ... / 변수명은 변경 불가
-> 변수명이 겹칠때는 as를 붙여 별칭을 만들 수 있음

---

(참고2)

# 컴포넌트

- 부분화면
- 함수형 컴포넌트 (권장사항)
  -> 화살표 함수 권장
- 클래스형 컴포넌트

# IP 주소 (서버의 주소)

- 공인 IP : 모든 네트워크에서 접근 가능한 주소
- 사설 IP : 내부 네트워크에서 접근 가능한 주소

  ipv4

  localhost : 서버, 현재 PC,
  127.0.0.1

  localhost:3000
  3000 -> 3000 포트
  => 데이터가 이동하는 통로

      80 => (HTTP 웹 문서)
      443 => (HTTPS)
