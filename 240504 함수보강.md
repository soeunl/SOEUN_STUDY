<240504 자바스크립트 보강>

## 자바스크립트의 함수

- 자바스크립트의 함수는 객체이다. -> 번역(평가) 과정이 필요함 -> 실행 가능 객체(EC)
- 자바스크립트는 함수명과 변수명이 동일하다. 변수명에는 함수객체의 주소값이 담겨있다.
- 함수가 아닌 함수 객체인 것 꼭 기억하기!
- 자바스크립트의 객체는 키와 값 형태 / 자바스크립트의 함수도 키와 값 형태
- 함수객체는 힙메모리에 저장된다.
- 함수명 = 변수명 = 참조변수 (모두 함수객체의 주소값을 가지고 있어서 다 같은것!)
- Function 키워드만 선언해도 Function 생성자로 만들어진 객체가 만들어진다. 그러므로 함수를 어디에 정의하든 어디에서나 호출이 가능! (window의 하위로 추가되기 때문이다.)

## 함수 정의 방법

1. 함수 리터럴(함수 표현식)로 정의하는 방법
   - const add = function(num1, num2) {
      return num1 + num2
   }
   - const 또는 let 키워드로 변수를 선언
   - 변수에 함수 리터럴을 할당함
   - 변수에 함수를 할당하고 나중에 사용할 때 사용
   - 함수 이름 없이 익명으로 사용 가능
   - 선언 이전에는 호출이 되지 않는다.

2. 함수 선언문으로 정의하는 방법
   - function add(num1, num2) {
      return num1 + num2
   }
   - function 키워드로 시작
   - 이것은 함수객체로 생성
   - 함수를 선언하고 즉시 실행할 때 사용하며 수 이름을 사용하여 호출
   - 선언 이전에 호출해도 호출이 된다. (호출하는 것을 함수보다 위에 적어도 호출이 된다는 말. 호이스팅)

3. Function 생성자로 정의하는 방법
   - const myFunction = new Function(parameter1, parameter2, ..., functionBody);
   - new Function 키워드로 Function 생성자를 호출
   - 괄호 안에 함수 매개변수를 쉼표로 구분하여 나열함 (선택 사항)
   - 마지막 인자로 함수 본문을 문자열 형태로 지정
   - const add = new Function("x", "y", "return x + y;");
      console.log(add(5, 3)); // 8 출력

4. 화살표 함수 표현식으로 정의하는 방법
   - 함수가 매개변수로 사용되는 경우 : 함수 내부에서만 제한적으로 사용, 사용자 정의기능, 정의한 하나의 역할(단일기능), 짧은 식의 형태(화살표함수)
   - 형식을 단순화 해서 사용

     1. function 키워드와, 함수명을 생략
     2. 매개변수와 구현 코드 부분 사이에 =>
     3. 구현 코드가 1줄일때는 {} 부분도 생략 가능, return은 생략
     4. 변수명도 최대한 짧게 사용
     5. 매개변수가 1개 -> (..) 생략 가능
     6. 매개변수가 없는 경우는 (..) 생략 불가
        
        (참고)
        일급 객체 / 일등 함수 - 함수를 변수와 동일하게 취급 - 함수가 객체 / 함수는 값 - 함수가 매개변수로 사용 가능 - 함수가 반환값으로 사용 가능
        -> 클로저 : 고차함수 - 함수형 프로그래밍
        화살표 함수의 this는 함수를 정의할 때 이미 결정된 this 값으로 결정
        정의할때부터 this는 결정되어 있음
   
## 함수객체

- 사실 함수객체는 함수가 아니라 혼자서 실행되지 못한다.
- 함수 객체는 번역과 평가의 과정을 거쳐 실행가능한 객체가 되어야 한다(힙메모리 저장)
- 힙메모리에 저장되었던 함수객체를 실행할때는 스택영역에서 메모리를 받아서 실행되고, 끝나면 제거된다.

## EC (Exceution Context)

- 자바스크립트 실행 컨텍스트 (Execution Context, EC)는 자바스크립트 코드가 실행되는 환경을 추상적으로 표현한 개념
- 쉽게 말해, EC는 코드 실행에 필요한 정보와 변수들을 담고 있는 가상의 공간이라고 생각하면 된다.
- 자바스크립트 함수는 혼자서 실행되지 못하므로 EC가 필요하다.

## EC의 주요 구성요소

- 변수 객체 (Variable Object): 선언된 변수와 함수의 이름과 값을 저장 (힙메모리 저장)
- 유효범위 체인 (Scope Chain): 변수를 찾을 때 참조하는 객체들의 순서를 나타냄. 가장 먼저 전역 객체를 참조하고, 해당 객체에서 변수를 찾지 못하면 유효범위 체인에 있는 다음 객체를 차례대로 참조함. (스택 메모리 저장)
- this 키워드: 현재 실행 중인 코드 블록에서 어떤 객체를 가리키는지 나타냄.

## EC가 생성되는 상황

- 스크립트 파일을 실행할 때
- function 키워드를 사용하여 함수를 선언할 때
- new 키워드를 사용하여 객체를 생성할 때

## EC는 다음과 같은 상황에서 메모리 영역에 할당됨

- 스크립트 파일을 실행할 때: 전역 EC가 생성되고 힙 메모리에 할당
- 함수를 호출할 때: 함수 EC가 생성되고 스택 메모리에 할당
- new 키워드를 사용하여 객체를 생성할 때: 객체 EC가 생성되고 힙 메모리에 할당

## 유효범위체인

- 자바스크립트 유효 범위 체인(Scope Chain)은 변수를 찾을 때 참조하는 객체들의 순서를 나타내는 개념
- 쉽게 말해, 코드 어디에서든 변수에 접근하려고 할 때 유효 범위 체인을 따라 변수를 찾아가는 과정이라고 생각하면 됨
- 변수는 선언된 함수 범위 내에서만 유효함
- 함수는 상위 함수에서 선언된 변수에 접근할 수 있음
- 모든 코드는 전역 객체에서 선언된 변수와 함수에 접근할 수 있음

## 호이스팅

- Global EC(전역실행환경)에서 자원의 재구성이 될 때 함수 내부에 구성된 변수 레코드(자원)들을 EC로 다 끌어올리는 것이다.

## 자바스크립트의 this

- 자바스크립트의 this는 처음에는 결정되어 있지 않다.
- 쉽게 말해, this는 ★코드를 실행하는 컨텍스트(문맥)★를 나타내는 참조 변수라고 생각하면 된다.
- this 키워드의 값은 함수가 호출되는 방식에 따라 동적으로 결정된다. 즉, 함수를 호출하는 방식에 따라 this가 가리키는 객체가 달라진다는 것!!!
- 일반 함수를 호출할 때 this는 **전역 객체(window 객체)**를 가리킨다.
- 객체의 메서드를 호출할 때 this는 메서드를 호출한 객체를 가리킨다.
- call() , bind() , apply() 메서드를 사용하여 함수를 호출할 때 this를 인위적으로 변경하는 것도 가능하다.
- 하지만 화살표함수는 이미 this가 결정되어 있다.
- 화살표 함수는 선언된 컨텍스트의 this를 상속한다. 즉, 화살표 함수 내부에서 this는 함수가 선언된 곳에서 this가 가리키는 객체를 가리키게 된다.
- 나머지는 this가 결정되어 있지 않다.

## call(), bind(), apply() 메서드 비교

- call(), bind(), apply() 메서드는 모두 함수 호출 방식을 변경하여 this 키워드가 가리키는 객체를 인위적으로 설정하는 데 사용된다.

apply(thisArg, ...)
call(thisArg, ...params)
bind(thisArg, ...params)

1. call() 메서드

함수를 호출하는 것처럼 보이지만, 첫 번째 인자로 this를 설정하고, 두 번째 인자부터는 함수 인수를 전달한다. this를 원하는 객체로 설정하여 객체 메서드처럼 호출할 수 있으며,
함수 호출 후 즉시 실행됨

2. apply() 메서드

함수를 호출하는 것처럼 보이지만, 첫 번째 인자로 this를 설정하고, 두 번째 인자로 배열 형태의 함수 인수를 전달한다. call()과 유사하지만, 인수를 배열 형태로 전달해야 하며, 함수 호출 후 즉시 실행됨

3. bind() 메서드

this를 설정하고 새로운 함수를 반환한다.반환된 함수는 call() 처럼 this를 설정하고 호출할 수 있다. 생성된 새로운 함수에 this를 설정하기 때문에 클로저 함수를 만들 때 유용

## 화살표 함수

- const greet = (name) => {
  console.log(name + "님, 안녕하세요!");
};
- 자바스크립트 화살표 함수는 간결하고 명확하게 함수를 정의하는 새로운 함수 문법
- 기존의 function 키워드를 사용하는 함수 정의 방식보다 더 짧고 간결하며, 특히 간단한 함수를 작성할 때 유용
- this 바인딩: 화살표 함수는 선언된 컨텍스트의 this를 상속함
- new 연산자를 사용하여 생성자 함수를 만들 수는 없음

## 재귀 함수

- 자기자신을 직접 호출하는 함수. 쉽게 말해, 함수 내부에서 동일한 함수를 다시 호출하여 문제를 해결하는 방식
- 같은 함수를 연속적으로 내부에서 호출하는 방법
- 재귀 함수는 무한히 호출되지 않도록 종료 조건을 명시적으로 정의해야 함
- 메모제이션 기법 활용 가능
- 메모제이션 기법 : 이전에 계산된 결과를 저장하여 동일한 입력에 대해 함수를 다시 호출할 때 저장된 결과를 사용하는 최적화 기법. 함수가 이미 계산한 값을 기억하고 있기 때문에 동일한 계산을 반복적으로 수행하지 않아도 됨

## 나머지 연산자

const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const [a, b, ...rest] = nums;

- a에는 1, b에는 2를 대입하고 나머지는 모두 rest에 대입함

## 가변인수

-  매개변수의 개수를 명시적으로 정하지 않고 동적으로 여러 개의 인수를 전달받아 처리할 수 있는 함수
- 함수를 호출할 때마다 전달되는 인수의 개수가 달라도 문제없이 동작하도록 설계할 수 있다는 의미

## 전개 연산자

[iterable-object, ...other-iterables]

const numbers1 = [1, 2, 3];
const numbers2 = [4, 5, 6];

const combinedNumbers = [...numbers1, ...numbers2];
console.log(combinedNumbers); // [1, 2, 3, 4, 5, 6] 출력

- 자바스크립트 전개 연산자는 리스트, 배열, 문자열 등의 iterable 객체를 개별 요소로 분해하여 새로운 리스트 또는 배열에 추가하는 연산자임
- 쉽게 말해, 기존 객체의 요소들을 하나씩 펼쳐서 새로운 구조체에 담는다는 의미

## 자바스크립트 싱글 스레드

- 쓰레드 - 작업공간 (작업 메서드 + 호출 스택)
- 자바스크립트는 동시성 작업을 여러 쓰레드를 생성하여 진행할 수 없음. 한 번에 하나의 작업만 처리할 수 있다는 의미
- 이벤 주도 방식의 위임, 비동기 방식
- 비동기 처리: callback, promise, async/await 등을 사용하여 비동기 처리를 구현해야 함